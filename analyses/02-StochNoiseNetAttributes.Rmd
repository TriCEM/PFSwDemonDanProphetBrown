---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Stochastic Noise & Bias from Network Features
In this section, we explore the network features/attributes that generate the greatest variation in the distribution of epidemic final sizes to answer the question: _"How does the variance in the final size distribution change as we vary properties of the network?")_. 

```{r, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = F, message = F, eval = T, results = 'hide',
                      fig.align = 'center', fig.width = 8, fig.height = 8)
knitr::opts_knit$set(root.dir = here::here())
```
```{r}
library(tidyverse)
library(fomes)
library(plotly)
library(DT)
source("R/themes.R")
```


```{r}
#............................................................
# read in and extract relevant information from simulations
#...........................................................
fns <- list.files("simulations/01_generated_simulation_runs/", recursive = T, pattern = ".RDS", full.names = T)
fns <- fns[stringr::str_detect(fns, "log", negate = T)] # drops logs
OGfns <- fns[stringr::str_detect(fns, "BIAS", negate = T)]
BIASfns <- fns[stringr::str_detect(fns, "BIAS", negate = F)]
```

## Stochastic Noise from Simulation 
Overall, we considered **16,625 different simulation parameters** with _100 repetitions_ across each of those sets, respectivley (to explore the variation in the final sizes).
```{r}
#............................................................
# extract relevant information
#...........................................................
# each OG RDS is a 100 indiviudal reps/realizations of a fomes model given a beta and durI w/r/t a netpath and val of that netpath 
OGextractfs <- function(pth) {
  ret <- readRDS(pth)
  ret %>% 
    dplyr::mutate(basenet = stringr::str_extract(basename(unique(ret$netpath)), "(?<=_)[0-9]+(?=\\.RDS$)")) %>% 
    dplyr::mutate(fs = purrr::map_dbl(fomesout, "FinalEpidemicSize")) %>%  
    dplyr::select(-c("seed", "fomesout")) %>% 
    dplyr::group_by(mod, beta, durI, val, basenet) %>% 
    tidyr::nest(finalsizes = fs)
}
#......................
# make results tbl
#......................
ogsimrets <- lapply(OGfns, OGextractfs) %>% 
  dplyr::bind_rows()

```

```{r}
#............................................................
# Newman Approx
#...........................................................
newmanappox <- readRDS("analyses/zbackend-large_simulation_sirpent_runs/newman_approximation_from_inputs.RDS")
#TODO 

```


```{r}
#............................................................
# Plotting Function
#...........................................................
#......................
# make generalizable plot
#......................
plotSimRet <- function(df, modname) {
  #......................
  # subset to plot df  
  #......................
  eqmodname <- rlang::enquo(modname)
  plotdf <- df %>% 
    dplyr::filter(mod == !!modname) 
  #......................
  # plotting items that are project specific 
  #......................
  # betas and durI 
  fctrowslvls <- tidyr::expand_grid(betaI = c(0.005, 0.01, 0.05, 0.075, 0.1), durationI = seq(3, 15, by = 3)) %>% 
    dplyr::mutate(bd = purrr::map2_chr(betaI, durationI, function(x,y){paste(x,y, sep = "; ")}),
                  bd = as.character(bd)) %>% 
    dplyr::pull(bd)
  
  # lvls
  if (modname == "degreedist") {
    mylvls <- tidyr::expand_grid(x = c(0.05, 0.1, 0.15, 0.2, 0.25), y = c(0, 1, 5, 10, 25)) %>%
      dplyr::mutate(val = purrr::map2_chr(x, y, function(x, y){paste(x, y, sep = "-")})) %>% 
      dplyr::pull(val)
  } else {
    mylvls <- as.character( sort(unique(as.numeric(plotdf$val))) )
  }
  
  # plot
  plotdf %>% 
    dplyr::mutate(basenetfct = factor(basenet, levels = 1:10, ordered = T),
                  valfct = factor(val, levels = mylvls, ordered = T),
                  transmission = paste(beta, durI, sep = "; "),
                  transmission_fct = factor(transmission, levels = fctrowslvls, ordered = T)) %>% 
    tidyr::unnest(finalsizes) %>% 
    ggplot() + 
    geom_boxplot(aes(x = valfct, y = fs, color = basenetfct),
                 outlier.shape = 8,
                 position = position_dodge(width = 0.75),
                 alpha = 0.5) +
    geom_point(aes(x = valfct, y = NewmanApprox),
               color = "#737373", shape = 18, size = 6, alpha = 0.75) +
    scale_color_viridis_d("Base Net. Layer") +
    facet_grid(rows = vars(transmission_fct)) +
    plot_theme + 
    xlab("Net Value Manipulation") + ylab("Final Size Dist.") + 
    labs(caption = "Grey diamond represents Newman dd-PGF Estimation")
}

```

### Degree Distribution
```{r, fig.width = 8, fig.height = 32}
plotObj <- plotSimRet(df = ogsimrets, modname = "degreedist")
plotly::ggplotly(plotObj)
```

### Modularity
```{r, fig.width = 8, fig.height = 32}
plotObj <- plotSimRet(df = ogsimrets, modname = "modularity")
plotly::ggplotly(plotObj)
```


### Unity
```{r, fig.width = 8, fig.height = 32}
plotObj <- plotSimRet(df = ogsimrets, modname = "unity")
plotly::ggplotly(plotObj)
```


### Clustering
```{r, fig.width = 8, fig.height = 32}
plotObj <- plotSimRet(df = ogsimrets, modname = "cluster")
plotly::ggplotly(plotObj)
```
Per [Keeling 2005](https://pubmed.ncbi.nlm.nih.gov/15649519/), clustering reduces the R_0 from the initial growth in part due to "pockets" of potential susceptibles that are randomly reached but then add fuel to the epidemic. 


### Dynamicity
```{r, fig.width = 8, fig.height = 32}
plotObj <- plotSimRet(df = ogsimrets, modname = "NEdynamicity")
plotly::ggplotly(plotObj)
```


## Divergence with Bias Introduced

```{r}

Biasextractfs <- function(pth) {
  ret <- readRDS(pth)
  ret %>% 
    dplyr::mutate(basenet = stringr::str_extract(basename(unique(ret$netpath)), "(?<=_)[0-9]+(?=\\.RDS$)")) %>% 
    dplyr::mutate(fs = purrr::map_dbl(fomesout, "FinalEpidemicSize")) %>%  
    dplyr::select(-c("seed", "netpath", "fomesout")) %>% 
    dplyr::group_by(mod, beta, durI, val, basenet) %>% 
    tidyr::nest(cols = fs)
}

```
